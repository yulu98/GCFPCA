[{"path":"https://yulu98.github.io/GCFPCA/articles/gcfpca.html","id":"the-gc-fpca-model-and-algorithm","dir":"Articles","previous_headings":"","what":"The GC-FPCA model and algorithm","title":"GC-FPCA: a vignette","text":"model generalized functional principal components analysis g(E[Zi(s)|X1,‚ãØ,Xp])=Œ≤0(s)+‚àër=1pXirŒ≤r(s)+‚àël=1LŒæilœïl(s) g\\left(E[Z_i(s) | X_1, \\cdots, X_p]\\right) = \\beta_0(s) + \\sum_{r=1}^{p} X_{ir} \\beta_r(s) + \\sum_{l=1}^{L} \\xi_{il} \\phi_l(s) Zi(s)Z_i(s) observed data time ss subject ii, Œ≤0(s)\\beta_0(s) Œ≤r(s)\\beta_r(s) domain-varying coefficient, Œæik‚àºN(0,Œªk)\\xi_{ik}\\sim N(0, \\lambda_k) mutually independent subject-specific scores, œïk(s);k‚àà1,‚Ä¶,K\\phi_k(s); k\\1,\\ldots,K eigenfunctions.","code":""},{"path":[]},{"path":"https://yulu98.github.io/GCFPCA/articles/gcfpca.html","id":"a-note-on-data-formatting","dir":"Articles","previous_headings":"The GCFPCA package","what":"A note on data formatting","title":"GC-FPCA: a vignette","text":"Like model-fitting functions R, lmer takes first two arguments formula specifying model data evaluate formula. formula use format required lme4:lmer. Use package requires data specific format: long-form data frame variables id, index, Y, fixed effect predictors, Y column contains functional observations subjects, id column identifies observations belong subject, index provides grid (domain) Ys observed, fixed effect predictors domain-dependent, repeated time point. variable id unique identifier id identifies single subject. Since assume one curve per subject package, id uniquely identifies curve well. predictors can included data long variables id, index, Y present.","code":"library(GCFPCA) library(tidyverse) library(lme4) library(refund) library(mvtnorm) library(splines) theme_set(theme_minimal())"},{"path":"https://yulu98.github.io/GCFPCA/articles/gcfpca.html","id":"simulate-data-for-gc-fpca","dir":"Articles","previous_headings":"The GCFPCA package","what":"Simulate data for GC-FPCA","title":"GC-FPCA: a vignette","text":"gcfpca_simu() generates curves population mean, fixed effect (binary gaussian distributed) K=4K = 4 functional principal components, true eigenvalues Œªk=0.5k‚àí1;k=1,2,3,4\\lambda_k = 0.5^{k-1}; k = 1,2,3,4. function argument fe_case = 1, fixed effect predictor Bernoulli(12)Bernoulli(\\frac12) distributed. fe_case = 2, fixed effect predictor N(0,1)N(0, 1) distributed. function argument re_case = 1, true eigenfunctions periodic defined ùõü(s)={2sin(2œÄs),2cos(2œÄs),2sin(4œÄs),2cos(4œÄs)}\\boldsymbol{\\phi}(s) = \\{\\sqrt{2}sin(2\\pi s), \\sqrt{2}cos(2\\pi s), \\sqrt{2}sin(4\\pi s), \\sqrt{2}cos(4\\pi s)\\}. re_case = 2, eigenfunctions non-periodic given ùõü(s)={1,3(2s‚àí1),5(6s2‚àí6s+1),7(20s3‚àí30s2+12s‚àí1)}.\\boldsymbol{\\phi}(s) = \\{1, \\sqrt{3}(2s-1), \\sqrt{5}(6s^2-6s + 1), \\sqrt{7}(20s^3-30s^2+12s-1)\\}. argument family defines outcome distribution observed data.code generates binary functional data =100I = 100 subjects K=200K = 200 grid points binary fixed effect predictor periodic eigenfunctions. resulting data object,simu_data, list values df_gcfpca, lambda, phi, scores. simu_data$df_gcfpca data frame variables id, index, Y, X, consistent format GCFPCA software requires. id identifier particular subject, index represents functional domain point, Y variable contains binary observations, X subject-specific fixed effect predictor.","code":"# simulate data  I = 100 K = 200  # simulate data and save results set.seed(1134)  #set true fixed effects theta_0 = rnorm(10 + 4, sd=1) theta_1 = rnorm(10 + 4, sd=1)  #set true fixed effects f_0 = function(s) bs(s, knots=seq(0.1, 0.9, len=10), Boundary.knots=c(0,1), intercept=TRUE) %*% theta_0 f_1 = function(s) bs(s, knots=seq(0.1, 0.9, len=10), Boundary.knots=c(0,1), intercept=TRUE) %*% theta_1  bin_sim <- gcfpca_simu(I = I, K = K, family = \"binomial\",                          beta0_true = f_0, beta1_true = f_1)  ls(bin_sim) #> [1] \"df_gcfpca\" \"lambda\"    \"phi\"       \"scores\""},{"path":"https://yulu98.github.io/GCFPCA/articles/gcfpca.html","id":"binary-outcomes","dir":"Articles","previous_headings":"The GCFPCA package","what":"Binary outcomes","title":"GC-FPCA: a vignette","text":"gcfpca() main function GCFPCA package. key arguments function listed . formula formula specifying GLMM model data data frame columns: id (subject), index (time index), Y (outcome variable). binwidth determines width bins. positive integer value ‚â§J/10\\le J/10. npc indicates number functional principal components use. latter can also chosen based explained share variance, see argument pve. family used specify type exponential family functional distribution link function like use data. parameter fed functions glm::glmer() mgcv::bam(); see help files functions types families link functions supported. following code uses binomial family logit link. plot show estimated fixed effect coefficients logit binary FPCA models. plot show estimated principal components logit binary FPCA models.  plot shows latent subject-specific means linear predictor scale, Œ≤0(s)+‚àër=1pXirŒ≤r(s)+‚àël=1LŒæilœïl(s)\\beta_0(s) + \\sum_{r=1}^p X_{ir} \\beta_r(s) + \\sum_{l=1}^L \\xi_{il} \\phi_l(s), three subjects simulated Poisson dataset. True values black solid lines GCFPCA estimates pink dotted lines.","code":"# run fast gfpca model bin_model <- gc_fpca(formula = Y ~ X + (1|id),                       data = bin_sim$df_gcfpca,                       binwidth = 10,                       family = \"binomial\",                       pve = 0.95, npc = 4) plot_df <- cbind.data.frame(sind = rep(seq(0, 1, length.out = K), 2),                             betahat = c(data.matrix(bin_model$betaHat)),                             betatrue = c(f_0(seq(0, 1, length.out = K)),                                          f_1(seq(0, 1, length.out = K))),                             X = c(rep(\"Intercept\", K),                                   rep(\"X\", K)),                             CI_L_pw = c(data.matrix(bin_model$CI_L_pw)),                             CI_U_pw = c(data.matrix(bin_model$CI_U_pw)),                             CI_L_joint = c(data.matrix(bin_model$CI_L_joint)),                             CI_U_joint = c(data.matrix(bin_model$CI_U_joint))) %>%   mutate(X = factor(X, levels = c(\"Intercept\",                                   \"X\")))  plot_df %>%   ggplot(aes(x = sind, y = betahat)) +   geom_ribbon(aes(ymin = CI_L_joint, ymax = CI_U_joint, fill = \"CI Joint\"), alpha = 0.5) +   geom_ribbon(aes(ymin = CI_L_pw, ymax = CI_U_pw, fill = \"CI\"), alpha = 0.5) +   geom_line(aes(color = \"GCFPCA\")) +   geom_line(aes(x = sind, y = betatrue, color = \"truth\")) +   scale_fill_manual(values = c(\"CI\" = \"black\", \"CI Joint\" = \"lightgray\"), name = \"Confidence Interval\") +   scale_color_manual(values = c(\"GCFPCA\" = \"darkblue\", \"truth\" = \"red\"), name = \"Confidence Interval\") +   # Adding a horizontal dotted line at y = 0   geom_hline(yintercept = 0, linetype = \"dotted\") +   # Setting x-axis labels to show time   scale_x_continuous(breaks = seq(0, 1, by = 0.2)) +   # Facet the plot by variable X, with 3 columns   facet_wrap(~X, ncol = 3, scales = \"free_y\") +   # Adding axis labels and title   labs(x = \"Functional Domain\", y = \"\", fill = \"Confidence Interval\") flip_efunctions = function(data){   if(data[[\"logit_mod\"]] %*% data[[\"truth\"]] < 0){     data[[\"logit_mod\"]] = -1 * data[[\"logit_mod\"]]   }   data }  phi_df = tibble(s = rep(seq(0, 1, length.out  = 200), 4),                 l = rep(paste0(\"eigenfunction \",1:4), each = 200),                 truth = c(bin_sim$phi),                 logit_mod = c(data.matrix(bin_model$efunctions[, -1]))) %>%   nest_by(l)   new_phi = map(phi_df$data, flip_efunctions) phi_df$new_phi <- new_phi  phi_df %>%   select(-data) %>%   unnest(new_phi) %>%   ungroup() %>%    mutate(logit_mod = logit_mod * sqrt(200)) %>%   pivot_longer(truth:logit_mod, names_to = \"model\", values_to = \"value\") %>%   ggplot(aes(s, value, group = model, color = model, linetype = model)) +   geom_line() +   facet_wrap(~l) bin_sim$df_gcfpca %>%   mutate(eta_hat = as.vector(bin_model$etas)) %>%   filter(id %in% c(1, 2, 8)) %>%   ggplot(aes(index, eta)) +   geom_line() +   geom_line(aes(y = eta_hat), linetype = 2, color = \"salmon\") +   facet_wrap(~id)"},{"path":"https://yulu98.github.io/GCFPCA/articles/gcfpca.html","id":"poisson-outcomes","dir":"Articles","previous_headings":"The GCFPCA package","what":"Poisson outcomes","title":"GC-FPCA: a vignette","text":"gcfpca() function can also perform Poisson GCFPCA count outcomes. code simulates Poisson functional data gaussian distributed fixed effect predictor non-periodic eigenfunctions, performs Poisson GCFPCA. plot show estimated fixed effect coefficients poisson FPCA models. plot show estimated principal components poisson FPCA models.  plot shows latent subject-specific means linear predictor scale, Œ≤0(s)+‚àër=1pXirŒ≤r(s)+‚àël=1LŒæilœïl(s)\\beta_0(s) + \\sum_{r=1}^p X_{ir} \\beta_r(s) + \\sum_{l=1}^L \\xi_{il} \\phi_l(s), three subjects simulated Poisson dataset. True values black solid lines GCFPCA estimates pink dotted lines.","code":"# simulate data library(splines)  I = 500 K = 1000  # simulate data and save results set.seed(1134)  #set true fixed effects theta_0 = rnorm(10 + 4, sd=1) theta_1 = rnorm(10 + 4, sd=1)  #set true fixed effects f_0 = function(s) bs(s, knots=seq(0.1, 0.9, len=10), Boundary.knots=c(0,1), intercept=TRUE) %*% theta_0 f_1 = function(s) bs(s, knots=seq(0.1, 0.9, len=10), Boundary.knots=c(0,1), intercept=TRUE) %*% theta_1  count_sim <- gcfpca_simu(I = I, K = K, family = \"poisson\",                          beta0_true = f_0, beta1_true = f_1,                          fe_case = 2, re_case = 2)  count_model <- gc_fpca(formula = Y ~ X + (1|id),                       data = count_sim$df_gcfpca,                       binwidth = 20,                       family = \"poisson\",                       pve = 0.95, npc = 4, periodicity = FALSE) plot_df <- cbind.data.frame(sind = rep(seq(0, 1, length.out = K), 2),                             betahat = c(data.matrix(count_model$betaHat)),                             betatrue = c(f_0(seq(0, 1, length.out = K)),                                          f_1(seq(0, 1, length.out = K))),                             X = c(rep(\"Intercept\", K),                                   rep(\"X\", K)),                             CI_L_pw = c(data.matrix(count_model$CI_L_pw)),                             CI_U_pw = c(data.matrix(count_model$CI_U_pw)),                             CI_L_joint = c(data.matrix(count_model$CI_L_joint)),                             CI_U_joint = c(data.matrix(count_model$CI_U_joint))) %>%   mutate(X = factor(X, levels = c(\"Intercept\",                                   \"X\")))  plot_df %>%   ggplot(aes(x = sind, y = betahat)) +   geom_ribbon(aes(ymin = CI_L_joint, ymax = CI_U_joint, fill = \"CI Joint\"), alpha = 0.5) +   geom_ribbon(aes(ymin = CI_L_pw, ymax = CI_U_pw, fill = \"CI\"), alpha = 0.5) +   geom_line(aes(color = \"GCFPCA\")) +   geom_line(aes(x = sind, y = betatrue, color = \"truth\")) +   scale_fill_manual(values = c(\"CI\" = \"black\", \"CI Joint\" = \"lightgray\"), name = \"Confidence Interval\") +   scale_color_manual(values = c(\"GCFPCA\" = \"darkblue\", \"truth\" = \"red\"), name = \"Confidence Interval\") +   # Adding a horizontal dotted line at y = 0   geom_hline(yintercept = 0, linetype = \"dotted\") +   # Setting x-axis labels to show time   scale_x_continuous(breaks = seq(0, 1, by = 0.2)) +   # Facet the plot by variable X, with 3 columns   facet_wrap(~X, ncol = 3, scales = \"free_y\") +   # Adding axis labels and title   labs(x = \"Functional Domain\", y = \"\", fill = \"Confidence Interval\") flip_efunctions = function(data){   if(data[[\"logit_mod\"]] %*% data[[\"truth\"]] < 0){     data[[\"logit_mod\"]] = -1 * data[[\"logit_mod\"]]   }   data }  phi_df = tibble(s = rep(seq(0, 1, length.out  = K), 4),                 l = rep(paste0(\"eigenfunction \",1:4), each = K),                 truth = c(count_sim$phi),                 logit_mod = c(data.matrix(count_model$efunctions[, -1]))) %>%   nest_by(l)   new_phi = map(phi_df$data, flip_efunctions) phi_df$new_phi <- new_phi  phi_df %>%   select(-data) %>%   unnest(new_phi) %>%   ungroup() %>%    mutate(logit_mod = logit_mod * sqrt(K)) %>%   pivot_longer(truth:logit_mod, names_to = \"model\", values_to = \"value\") %>%   ggplot(aes(s, value, group = model, color = model, linetype = model)) +   geom_line() +   facet_wrap(~l) count_sim$df_gcfpca %>%   mutate(eta_hat = as.vector(count_model$etas)) %>%   filter(id %in% c(1, 2, 8)) %>%   ggplot(aes(index, eta)) +   geom_line() +   geom_line(aes(y = eta_hat), linetype = 2, color = \"salmon\") +   facet_wrap(~id)"},{"path":"https://yulu98.github.io/GCFPCA/articles/gcfpca.html","id":"real-data","dir":"Articles","previous_headings":"The GCFPCA package","what":"Real data","title":"GC-FPCA: a vignette","text":"subsetting NHANES data show example apply method real life data. processed single level NHANES physical activity data can found website Functional Data Analysis R book website (https://functionaldataanalysis.org/dataset_nhanes.html). dataset also included packge nhanes_fda_with_r.rds. deleted missingness subsetted 50 subjects show method. First, fit GCFPCA model subsetted data. ${\\rm logit}\\{P\\{Z_i(s)=1\\}\\} = \\beta_0(s) + \\beta_1(s) \\text{Age}_i + \\beta_2(s) \\text{Gender}_i + \\sum_{l=1}^{4} \\xi_{il}\\phi_l(s)$ compare model GFAMM (Scheipl et al., 2015, 2016) using pffr functions refund package. ${\\rm logit}\\{P\\{Z_i(s)=1\\}\\} = \\beta_0(s) + \\beta_1(s) \\text{Age}_i + \\beta_2(s) \\text{Gender}_i + b_i(s)$ plot show estimated fixed effect coefficients GC-FPCA GFAMM models subsampled NHANES dataset  plot shows latent subject-specific means linear predictor scale, ${\\rm logit}\\{P\\{Z_i(s)=1\\}\\} = \\beta_0(s) + \\beta_1(s) \\text{Age}_i + \\beta_2(s) \\text{Gender}_i + b_i(s)$, three subjects subsampled NHANES dataset. GFAMM estimates black solid lines GCFPCA estimates pink dotted lines.  estimates GC-FPCA GFAMM similar fixed effects linear predictors. plot show estimated principal components GC-FPCA models.","code":"df_long <- readRDS(\"../data/df_long.rds\") gcfpca_start_t = Sys.time() nhanes_gcfpca <- gc_fpca(formula = mims ~ age + gender +(1|id),                          data = df_long,                          binwidth = 30,                          family = \"binomial\",                          pve = 0.95, npc = 4, periodicity = TRUE) gcfpca_end_t = Sys.time() gcfpca_time_diff = as.double(difftime(gcfpca_end_t, gcfpca_start_t, units=\"mins\")) gcfpca_time_diff #> [1] 27.92392 I = length(unique(df_long$id)) K = length(unique(df_long$index))  df_pffr <- data.frame(Y = I(matrix(df_long$mims, I, K, byrow=TRUE)),                        id = factor(unique(df_long$id)),                        age = df_long$age[!duplicated(df_long$id)],                       gender = df_long$gender[!duplicated(df_long$id)])  pffr_start_t = Sys.time() pffr_model <- pffr(Y ~ age + gender + s(id, bs=\"re\"),                   # use mgcv::bam with fastREML smoothing parameter                   # selection to estimate the model                  algorithm=\"bam\", method=\"fREML\", discrete=TRUE,                  # specify the bases used for estimating f_0(s), f_1(s)                   #via bs.int and bs.yindex, respectively                  bs.yindex=list(bs = \"cr\", k=60),                  bs.int=list(bs=\"cr\", k=60),                  data=df_pffr,                  # specify outcome distribution and the functional domain (yind)                  family=\"binomial\", yind=1:1440) pffr_end_t = Sys.time() pffr_time_diff = as.double(difftime(pffr_end_t, pffr_start_t, units=\"mins\"))  pffr_time_diff  #> [1] 5.53111  sind = 1:1440 df_pred <- data.frame(\"yindex.vec\" = sind,                        id = as.numeric(levels(df_long$id))[1],                        age = 1, gender = 1) betahat_pffr <- mgcv::predict.gam(pffr_model, newdata=df_pred, type='iterms', se.fit=TRUE) CI_L_pffr <- betahat_pffr[[1]] - 1.96 * betahat_pffr[[2]] CI_U_pffr <- betahat_pffr[[1]] + 1.96 * betahat_pffr[[2]]  eta_pffr <- matrix(pffr_model$linear.predictors, nrow = 50, ncol = 1440) plot_df <- cbind.data.frame(sind = rep(seq(0, 1, length.out = K), 3),                             betahat = c(data.matrix(nhanes_gcfpca$betaHat)),                             betahat_pffr = c(data.matrix(betahat_pffr[[1]][, -4])),                             X = c(rep(\"Intercept\", K),                                   rep(\"Age\", K),                                   rep(\"Gender\", K)),                             CI_L_pw = c(data.matrix(nhanes_gcfpca$CI_L_pw)),                             CI_U_pw = c(data.matrix(nhanes_gcfpca$CI_U_pw)),                             CI_L_joint = c(data.matrix(nhanes_gcfpca$CI_L_joint)),                             CI_U_joint = c(data.matrix(nhanes_gcfpca$CI_U_joint)),                             CI_L_pffr = c(CI_L_pffr[, -4]),                             CI_U_pffr = c(CI_U_pffr[, -4])) %>%   mutate(X = factor(X, levels = c(\"Intercept\",                                   \"Age\",                                   \"Gender\")))  plot_df %>%   ggplot(aes(x = sind, y = betahat)) +   #geom_ribbon(aes(ymin = CI_L_joint, ymax = CI_U_joint, fill = \"CI Joint\"), alpha = 0.5) +   geom_ribbon(aes(ymin = CI_L_pw, ymax = CI_U_pw, fill = \"CI\"), alpha = 0.3) +   geom_ribbon(aes(ymin = CI_L_pffr, ymax = CI_U_pffr, fill = \"CI pffr\"), alpha = 0.5) +   geom_line(aes(color = \"GCFPCA\")) +   geom_line(aes(x = sind, y = betahat_pffr, color = \"GFAMM\")) +   scale_fill_manual(values = c(\"CI\" = \"blue\", \"CI Joint\" = \"lightblue\", \"CI pffr\" = \"pink\"), name = \"Confidence Interval\") +   scale_color_manual(values = c(\"GCFPCA\" = \"blue\", \"GFAMM\" = \"red\"), name = \"Confidence Interval\") +   # Adding a horizontal dotted line at y = 0   geom_hline(yintercept = 0, linetype = \"dotted\") +   # Setting x-axis labels to show time   scale_x_continuous(breaks = seq(0, 1, by = 0.2)) +   # Facet the plot by variable X, with 3 columns   facet_wrap(~X, ncol = 3, scales = \"free_y\") +   # Adding axis labels and title   labs(x = \"Functional Domain\", y = \"\", fill = \"Confidence Interval\") df_long %>%   mutate(eta_hat = as.vector(nhanes_gcfpca$etas)) %>%   mutate(eta_pffr = as.vector(eta_pffr)) %>%   filter(id %in% c(63529, 67427, 82257)) %>%   ggplot(aes(index, eta_pffr)) +   geom_line() +   geom_line(aes(y = eta_hat), linetype = 2, color = \"salmon\") +   facet_wrap(~id) phi_df = tibble(s = rep(seq(0, 1, length.out  = 1440), 4),                 l = rep(paste0(\"eigenfunction \", 1:4), each = 1440),                 logit_mod = c(data.matrix(nhanes_gcfpca$efunctions[, -1]))) %>%   nest_by(l)   phi_df %>%   unnest(data) %>%   ungroup() %>%    mutate(logit_mod = logit_mod * sqrt(1440)) %>%   pivot_longer(logit_mod, names_to = \"model\", values_to = \"value\") %>%   ggplot(aes(s, value, group = model, color = model, linetype = model)) +   geom_line(color = \"black\") +   facet_wrap(~l)"},{"path":"https://yulu98.github.io/GCFPCA/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Yu Lu. Author, maintainer. Xinkai Zhou. Author. Erjia Cui. Author. Dustin Rogers. Author. Ciprian Crainiceanu. Author. Julia Wrobel. Author. Andrew Leroux. Author.","code":""},{"path":"https://yulu98.github.io/GCFPCA/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lu Y, Zhou X, Cui E, Rogers D, Crainiceanu C, Wrobel J, Leroux (2024). GCFPCA: Generalized Conditional Functional Principal Component Analysis. R package version 0.0.0.9000, https://yulu98.github.io/GCFPCA/.","code":"@Manual{,   title = {GCFPCA: Generalized Conditional Functional Principal Component Analysis},   author = {Yu Lu and Xinkai Zhou and Erjia Cui and Dustin Rogers and Ciprian Crainiceanu and Julia Wrobel and Andrew Leroux},   year = {2024},   note = {R package version 0.0.0.9000},   url = {https://yulu98.github.io/GCFPCA/}, }"},{"path":"https://yulu98.github.io/GCFPCA/index.html","id":"gcfpca","dir":"","previous_headings":"","what":"Generalized Conditional Functional Principal Component Analysis","title":"Generalized Conditional Functional Principal Component Analysis","text":"Generalized Conditional Functional Principal Components Analysis (GCFPCA) R package performing functional principal component analysis generalized exponential family distributions. Authors: Yu Lu, Xinkai Zhou, Erjia Cui, Dustin Rogers, Ciprian Crainiceanu, Julia Wrobel, Andrew Leroux Version: 0.9","code":""},{"path":"https://yulu98.github.io/GCFPCA/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Generalized Conditional Functional Principal Component Analysis","text":"can install development version GCFPCA GitHub:","code":"# install.packages(\"devtools\") devtools::install_github(\"yulu98/GCFPCA\", build_vignettes = TRUE)"},{"path":"https://yulu98.github.io/GCFPCA/index.html","id":"documentation-and-examples","dir":"","previous_headings":"","what":"Documentation and Examples","title":"Generalized Conditional Functional Principal Component Analysis","text":"detailed examples usage GCFPCA package, please refer vignette available pkgdown website.","code":""},{"path":"https://yulu98.github.io/GCFPCA/reference/gc_fpca.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Conditional Functional Principal Components Analysis (GC-FPCA) ‚Äî gc_fpca","title":"Generalized Conditional Functional Principal Components Analysis (GC-FPCA) ‚Äî gc_fpca","text":"main function GCFPCA package.","code":""},{"path":"https://yulu98.github.io/GCFPCA/reference/gc_fpca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized Conditional Functional Principal Components Analysis (GC-FPCA) ‚Äî gc_fpca","text":"","code":"gc_fpca(   formula,   data,   binwidth = 10,   family = \"gaussian\",   pve = NULL,   npc = NULL,   periodicity = FALSE,   ... )"},{"path":"https://yulu98.github.io/GCFPCA/reference/gc_fpca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized Conditional Functional Principal Components Analysis (GC-FPCA) ‚Äî gc_fpca","text":"formula formula specifying GLMM model. data data frame columns: id (subject), index (time index), Y (outcome variable). binwidth Numeric; controls width bins local fitting. Defaults 10. family family object specifying distribution link function GLMM. Defaults binomial. pve Numeric; proportion variance explained, used choose number principal components unless npc specified. npc Numeric; number smooth PCs extract. NULL, npc chosen based pve. ... Additional arguments passed mgcv::bam function.","code":""},{"path":"https://yulu98.github.io/GCFPCA/reference/gc_fpca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized Conditional Functional Principal Components Analysis (GC-FPCA) ‚Äî gc_fpca","text":"object class gc_fpca containing: betaHat Estimated fixed effects coefficient functions betaHat.sd Estimated fixed effects coefficient standard deviation along functional domain efunctions \\(K \\times npc\\) matrix estimated FPC basis functions. scores \\(\\times npc\\) matrix estimated FPC scores. mu Estimated population-level mean function. Yhat FPC approximation subject-specific means. family family used GLMM.","code":""},{"path":"https://yulu98.github.io/GCFPCA/reference/gc_fpca.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized Conditional Functional Principal Components Analysis (GC-FPCA) ‚Äî gc_fpca","text":"","code":"# Simulate data and fit GC-FPCA df_list <- gen_data(N = 100, J = 50, run_num = 1) #> Error in gen_data(N = 100, J = 50, run_num = 1): could not find function \"gen_data\" gcfpca_mod <- gc_fpca(df_list, bin_width = 10, family = binomial()) #> Error: object 'df_list' not found"},{"path":"https://yulu98.github.io/GCFPCA/reference/gcfpca_simu.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate longitudinal functional response Y (matrix) and a scalar predictor X (vector) ‚Äî gcfpca_simu","title":"Simulate longitudinal functional response Y (matrix) and a scalar predictor X (vector) ‚Äî gcfpca_simu","text":"Simulate longitudinal functional response Y (matrix) scalar predictor X (vector)","code":""},{"path":"https://yulu98.github.io/GCFPCA/reference/gcfpca_simu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate longitudinal functional response Y (matrix) and a scalar predictor X (vector) ‚Äî gcfpca_simu","text":"","code":"gcfpca_simu(   family = \"gaussian\",   I = 100,   K = 100,   beta0_true,   beta1_true,   fe_case = 1,   re_case = 1 )"},{"path":"https://yulu98.github.io/GCFPCA/reference/gcfpca_simu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate longitudinal functional response Y (matrix) and a scalar predictor X (vector) ‚Äî gcfpca_simu","text":"family distribution longitudinal functional data, including \"gaussian\", \"binomial\", \"poisson\". number subjects. K number grid points functional domain. beta0_true true intercept function. beta1_true true fixed effect function. fe_case Takes values 1 2. case = 1, true fixed effect coefficient generated Bernoulli(0.5) distribution . case = 2 true fixed effect, coefficient N(0,1) distribution. re_case Takes values 1 2. case = 1 true eigenfunctions based alternating sine cosines. case = 2 true eigenfunctions based sqrt functions.","code":""},{"path":"https://yulu98.github.io/GCFPCA/reference/gcfpca_simu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate longitudinal functional response Y (matrix) and a scalar predictor X (vector) ‚Äî gcfpca_simu","text":"data frame containing generated predictors longitudinal functional outcomes.","code":""}]
